---
layout: docs
title: Creating Contracts
permalink: /docs/creating-contracts/
---

Contracts can be created "from outside" or from Solidity contracts.
When a contract is created, its constructor (a function with the same
name as the contract) is executed once.

From `web3.js`, i.e. the JavaScript
API, this is done as follows:
{% highlight javascript %}
// The json abi array generated by the compiler
var abiArray = [
  {
    "inputs":[
      {"name":"x","type":"uint256"},
      {"name":"y","type":"uint256"}
    ],
    "type":"constructor"
  },
  {
    "constant":true,
    "inputs":[],
    "name":"x",
    "outputs":[{"name":"","type":"bytes32"}],
    "type":"function"
  }
];

var MyContract = web3.eth.contract(abiArray);
// deploy new contract
var contractInstance = MyContract.new(
  10,
  {from: myAccount, gas: 1000000}
);
{% endhighlight %}

Internally, constructor arguments are passed after the code of
the contract itself, but you do not have to care about this
if you use `web3.js`.

If a contract wants to create another contract, the source code
(and the binary) of the created contract has to be known to the creator.
This means that cyclic creation dependencies are impossible.

{% highlight javascript %}
contract OwnedToken {
  // TokenCreator is a contract type that is defined below.
  // It is fine to reference it as long as it is not used
  // to create a new contract.
  TokenCreator creator;
  address owner;
  bytes32 name;
  // This is the constructor which registers the
  // creator and the assigned name.
  function OwnedToken(bytes32 _name) {
    owner = msg.sender;
    // We do an explicit type conversion from `address`
    // to `TokenCreator` and assume that the type of
    // the calling contract is TokenCreator, there is
    // no real way to check that.
    creator = TokenCreator(msg.sender);
    name = _name;
  }
  function changeName(bytes32 newName) {
    // Only the creator can alter the name --
    // the comparison is possible since contracts
    // are implicitly convertible to addresses.
    if (msg.sender == creator) name = newName;
  }
  function transfer(address newOwner) {
    // Only the current owner can transfer the token.
    if (msg.sender != owner) return;
    // We also want to ask the creator if the transfer
    // is fine. Note that this calls a function of the
    // contract defined below. If the call fails (e.g.
    // due to out-of-gas), the execution here stops
    // immediately.
    if (creator.isTokenTransferOK(owner, newOwner))
      owner = newOwner;
  }
}

contract TokenCreator {
  function createToken(bytes32 name)
       returns (OwnedToken tokenAddress)
  {
    // Create a new Token contract and return its address.
    // From the JavaScript side, the return type is simply
    // "address", as this is the closest type available in
    // the ABI.
    return new OwnedToken(name);
  }
  function changeName(OwnedToken tokenAddress, bytes32 name) {
    // Again, the external type of "tokenAddress" is
    // simply "address".
    tokenAddress.changeName(name);
  }
  function isTokenTransferOK(
      address currentOwner,
      address newOwner
  ) returns (bool ok) {
    // Check some arbitrary condition.
    address tokenAddress = msg.sender;
    return (sha3(newOwner) & 0xff) == (bytes20(tokenAddress) & 0xff);
  }
}
{% endhighlight %}
