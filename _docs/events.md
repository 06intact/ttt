---
layout: docs
title: Events
permalink: /docs/events/
---

Events allow the convenient usage of the EVM logging facilities,
which in turn can be used to "call" JavaScript callbacks in the user interface
of a dapp, which listen for these events.

Events are
inheritable members of contracts. When they are called, they cause the
arguments to be stored in the transaction's log - a special data structure
in the blockchain. These logs are associated with the address of
the contract and will be incorporated into the blockchain
and stay there as long as a block is accessible (forever as of
Frontier and Homestead, but this might change with Serenity). Log and
event data is not accessible from within contracts (not even from
the contract that created a log).

SPV proofs for logs are possible, so if an external entity supplies
a contract with such a proof, it can check that the log actually
exists inside the blockchain (but be aware of the fact that
ultimately, also the block headers have to be supplied because
the contract can only see the last 256 block hashes).

Up to three parameters can
receive the attribute `indexed` which will cause the respective arguments
to be searched for: It is possible to filter for specific values of
indexed arguments in the user interface.

If arrays (including `string` and `bytes`) are used as indexed arguments, the
sha3-hash of it is stored as topic instead.

The hash of the signature of the event is one of the topics except if you
declared the event with `anonymous` specifier. This means that it is
not possible to filter for specific anonymous events by name.

All non-indexed arguments will be stored in the data part of the log.

{% highlight javascript %}
contract ClientReceipt {
  event Deposit(
    address indexed _from,
    bytes32 indexed _id,
    uint _value
  );
  function deposit(bytes32 _id) {
    // Any call to this function (even deeply nested) can
    // be detected from the JavaScript API by filtering
    // for `Deposit` to be called.
    Deposit(msg.sender, _id, msg.value);
  }
}
{% endhighlight %}

The use in the JavaScript API would be as follows:
{% highlight JavaScript %}
var abi = /* abi as generated by the compiler */;
var ClientReceipt = web3.eth.contract(abi);
var clientReceipt = ClientReceipt.at(0x123 /* address */);

var event = clientReceipt.Deposit();

// watch for changes
event.watch(function(error, result){
  // result will contain various information
  // including the argumets given to the Deposit
  // call.
  if (!error)
    console.log(result);
});

// Or pass a callback to start watching immediately
var event = clientReceipt.Deposit(function(error, result) {
  if (!error)
    console.log(result);
});

{% endhighlight %}


### Low-Level Interface to Logs

It is also possible to access the low-level interface to the logging
mechanism via the functions `log0`, `log1`, `log2`, `log3` and `log4`.
`logi` takes `i + 1` parameter of type `bytes32`, where the first
argument will be used for the data part of the log and the others
as topics. The event call above can be performed in the same way as
{% highlight javascript %}
log3(
  msg.value,
  0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20,
  msg.sender,
  _id
);`
{% endhighlight javascript %}
where the long hexadecimal number is equal to
`sha3("Deposit(address,hash256,uint256)")`, the signature of the event.

### Additional Resources for Understanding Events:

- Javascript documentation: <https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events>
- Example usage of events: <https://github.com/debris/smart-exchange/blob/master/lib/contracts/SmartExchange.sol>
- How to access them in js: <https://github.com/debris/smart-exchange/blob/master/lib/exchange_transactions.js>

