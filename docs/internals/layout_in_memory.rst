
.. index: memory layout

****************
Layout in Memory
****************

Reserved Memory Areas
=====================

Solidity reserves four 32-byte slots, with specific byte ranges (inclusive of endpoints) being used as follows:

- ``0x00`` - ``0x3f`` (64 bytes): scratch space for hashing methods
- ``0x40`` - ``0x5f`` (32 bytes): allocated memory size (aka. free memory pointer)
- ``0x60`` - ``0x7f`` (32 bytes): zero slot

Memory Allocation
-----------------

Solidity is a high level language that is translated (compiled) into EVM instructions. Its features
work because of the conventions Solidity defines and uses, in combination with the implementations
of complex data structures that it provides (such as multi-dimensional arrays). These data
structures require that memory be allocated (reserved) for their use, so that instructions that
execute after they're allocated don't corrupt them.

Memory allocation is a high-level concept, not an EVM concept. Its implementation in Solidity relies
on the value of the free memory pointer stored at location ``0x40``. That value tracks the next
unallocated memory address available.
The Solidity compiler generates code that always places new objects at the location pointed to by
the free memory pointer.
In inline assembly memory can be allocated manually by increasing the value of the pointer.

Memory access opcodes in inline assembly are not restricted by the value of the free memory pointer
and can freely refer to memory located beyond it.

Memory in Solidity is never freed.
In other words, the value of the free memory pointer is never decremented by the code automatically
generated by the compiler.
This might change in future versions.

Active Memory and Memory Expansion
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The concept of *allocated memory* is distinct and separate from *active memory*.

The active memory size is tracked by the EVM and represents the highest memory address ever accessed
by the contract's code.
Its value is available via the inline assembly instruction ``msize()`` (see
the :ref:`list of opcodes <opcodes>`).

The size of allocated memory is managed by code automatically generated by the compiler,
which adjusts the value of the free memory pointer as necessary.
There are no dedicated opcodes for managing the pointer.
The slot holding pointer's value is just an ordinary memory location.

Accessing the free memory pointer itself is a memory access and after such an access ``msize()``
would (by definition) return a value that is no smaller than the location of the pointer plus its size.

Increasing the size of active memory is called *memory expansion* and incurs an extra gas cost that
grows non-linearly the size of that memory.
The specifics are beyond the scope of this documentation.
More information about gas costs can be found in the Etherum Yellow Paper and the documentation of
specific EVM implementations.

Scratch Space
-------------

The memory between locations ``0x00`` and ``0x3F`` (inclusive) is called the *scratch space*. It exists
solely by convention. Solidity's generated code observes the convention that this area is for
extremely brief temporary use only. Since there is no guarantee that code not under your direct
control will not change that memory, you should not rely on its value being preserved between statements
except within the current assembly block.

.. warning::
    There are some operations in Solidity that need a temporary memory area
    larger than 64 bytes and therefore will not fit into the scratch space.
    Code for these operations therefore uses the unallocated area past
    the free memory pointer. Because such operations are known to be complete
    before the next instruction or operation managed by Solidity, the generated
    code does not update the free memory pointer. The memory used in such operations
    may or may not be zeroed out after the operation is complete. Solidity's
    access of that memory may affect ``msize()``. Thus, it is reasonable to expect that
    ``msize()`` might be larger than the value of the free memory pointer.

    While it may seem like a good idea to use ``msize()`` to arrive at a
    definitely zeroed out memory area (by using the memory just beyond its
    return value) using such a pointer non-temporarily without updating the
    free memory pointer can have unexpected results. Nothing prevents inline assembly
    from accessing any memory location whatsoever, but updating the free memory pointer
    at least ensures that Solidity itself won't unexpectedly use memory
    located below its value.

Zero Slot
---------

The zero slot at ``0x60`` was used as the initial value for dynamic memory arrays by earlier versions
of Solidity, and may still be used for that purpose. It must never
be written to. See `Layout of Arrays in Memory`.


Layout of Arrays in Memory
==========================

Elements in memory arrays in Solidity always occupy multiples of 32 bytes, i.e.
one slot (this is even true for ``bytes1[]``, but not for ``bytes`` and ``string``).
Multi-dimensional memory arrays are pointers to memory arrays. The length of a
dynamic array is stored at the first slot of the array and followed by the array
elements.

Dynamically sized memory arrays (e.g., ``uint[]``) store their length in
the first slot pointed to by the array variable, followed by its elements in the following
slots. Once allocated, such arrays cannot change their size.

.. note::
    In the current version of Solidity it does not cause an error to manually decrease the length of
    a dynamically sized array by manipulating its length field.
    Increasing it, on the other hand, has potential to corrupt other variables.

.. warning::
    Statically-sized memory arrays do not have a length field, but it might be added in a future version
    to allow better convertibility between statically- and dynamically-sized arrays, so
    do not rely on this.


Differences to Layout in Storage
================================

As described above the layout in memory is different from the layout in
:ref:`storage<storage-inplace-encoding>`. Below there are some examples.

Example for Difference in Arrays
--------------------------------

The following array occupies 32 bytes (1 slot) in storage, but 128
bytes (4 items with 32 bytes each) in memory.

.. code-block:: solidity

    uint8[4] a;



Example for Difference in Struct Layout
---------------------------------------

The following struct occupies 96 bytes (3 slots of 32 bytes) in storage,
but 128 bytes (4 items with 32 bytes each) in memory.


.. code-block:: solidity

    struct S {
        uint a;
        uint b;
        uint8 c;
        uint8 d;
    }
