
.. index: memory layout

****************
Layout in Memory
****************

Reserved Memory Areas
=====================

Solidity reserves four 32-byte slots, with specific byte ranges (inclusive of endpoints) being used as follows:

- ``0x00`` - ``0x3f`` (64 bytes): scratch space for hashing methods
- ``0x40`` - ``0x5f`` (32 bytes): allocated memory size (aka. free memory pointer)
- ``0x60`` - ``0x7f`` (32 bytes): zero slot

Memory Allocation
-----------------

Solidity compiles to EVM instructions, and implements its complex data types on top of
EVM features. Memory allocation is not an EVM feature. Inestead, Solidity implements its
memory allocation via the free memory pointer stored at location ``0x40``. That value tracks the next
unallocated memory address available.
The Solidity compiler generates code that always places new objects at the location pointed to by
the free memory pointer.
In inline assembly memory can be allocated manually by increasing the value of the pointer.

Memory located beyond the value of the free memory pointer is considered scratch memory.
Access to memory in inline assembly is not restricted by the value of the free memory pointer
and can freely refer to memory located beyond it.

Allocated memory in Solidity is never freed.
In other words, the value of the free memory pointer is never reduced by Solidity.
This might change in future versions.

Active Memory and Memory Expansion
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The concept of *allocated memory* is distinct and separate from *active memory*.

The active memory size is tracked by the EVM and represents the highest memory address ever accessed
by the contract's code.
Its value is available via the inline assembly instruction ``msize()`` (see
the :ref:`list of opcodes <opcodes>`).

The size of allocated memory is managed by code automatically generated by the compiler,
which adjusts the value of the free memory pointer as necessary.
There are no dedicated opcodes for managing the pointer.
The slot holding pointer's value is just an ordinary memory location.

Accessing the free memory pointer itself is a memory access and after such an access ``msize()``
would (by definition) return a value that is no smaller than the location of the pointer plus its size.

Increasing the size of active memory is called *memory expansion* and incurs an extra gas cost that
grows non-linearly the size of that memory.
The specifics are beyond the scope of this documentation.
More information about gas costs can be found in the Etherum Yellow Paper and the documentation of
specific EVM implementations.

Scratch Space
-------------

The memory between locations ``0x00`` and ``0x3F`` (inclusive) is called the *scratch space*. It exists
solely by convention. Solidity's generated code observes the convention that this area is for
temporary use only. Specifically, since there is no guarantee that code not under your direct
control will not change that memory, you should not rely on its value being preserved except
within the current assembly block.

.. warning::
    There are some operations in Solidity that need a temporary memory area
    larger than 64 bytes and therefore will not fit into the scratch space.
    Code for these operations therefore uses the unallocated area past
    the free memory pointer. Because such operations are known to be complete
    before the next instruction or operation managed by Solidity, the generated
    code does not update the free memory pointer. The memory used in such operations
    may or may not be zeroed out after the operation is complete. Solidity's
    access of that memory may affect ``msize()``. Thus, it is reasonable to expect that
    ``msize()`` might be larger than the value of the free memory pointer.

    While it may seem like a good idea to use ``msize()`` to arrive at a
    definitely zeroed out memory area (by using the memory just beyond its
    return value) using such a pointer non-temporarily without updating the
    free memory pointer can have unexpected results. Nothing prevents inline assembly
    from accessing any memory location whatsoever, but updating the free memory pointer
    at least ensures that Solidity itself won't unexpectedly use memory
    located below its value.

Zero Slot
---------

The memory slot at ``0x60``, by convention, always has the value of zero, and may be used by the
compiler for empty dynamic memory array variables.
The zero slot must never be written to.

The use of the zero slot allows the compiler to avoid allocating new empty arrays for uninitialized
variables.
It should be considered an implementation detail and is not guaranteed.
You should not assume that all uninitialized dynamically sized memory arrays point at this slot.


Layout of Arrays in Memory
==========================

Elements in memory arrays in Solidity always occupy multiples of 32 bytes, i.e.
one slot (this is even true for ``bytes1[]``, but not for ``bytes`` and ``string``).
Multi-dimensional memory arrays are pointers to memory arrays. The length of a
dynamic array is stored at the first slot of the array and followed by the array
elements.

Dynamically sized memory arrays (e.g., ``uint[]``) store their length in
the first slot pointed to by the array variable, followed by its elements in the following
slots. Once allocated, such arrays cannot change their size.

.. note::
    In the current version of Solidity it does not cause an error to manually decrease the length of
    a dynamically sized array by manipulating its length field.
    Increasing it, on the other hand, has potential to corrupt other variables.

.. warning::
    Statically-sized memory arrays do not have a length field, but it might be added in a future version
    to allow better convertibility between statically- and dynamically-sized arrays, so
    do not rely on this.


Differences to Layout in Storage
================================

As described above the layout in memory is different from the layout in
:ref:`storage<storage-inplace-encoding>`. Below there are some examples.

Example for Difference in Arrays
--------------------------------

The following array occupies 32 bytes (1 slot) in storage, but 128
bytes (4 items with 32 bytes each) in memory.

.. code-block:: solidity

    uint8[4] a;



Example for Difference in Struct Layout
---------------------------------------

The following struct occupies 96 bytes (3 slots of 32 bytes) in storage,
but 128 bytes (4 items with 32 bytes each) in memory.


.. code-block:: solidity

    struct S {
        uint a;
        uint b;
        uint8 c;
        uint8 d;
    }
