
.. index: memory layout

****************
Layout in Memory
****************

Reserved Memory Areas
=====================

Solidity reserves four 32-byte slots, with specific byte ranges (inclusive of endpoints) being used as follows:

- ``0x00`` - ``0x3f`` (64 bytes): scratch space for hashing methods
- ``0x40`` - ``0x5f`` (32 bytes): allocated memory size (aka. free memory pointer)
- ``0x60`` - ``0x7f`` (32 bytes): zero slot

Solidity is a high level language that is translated (compiled) into EVM instructions. Its features
work because of the conventions Solidity defines and uses, in combination with the implementations
of complex data structures that it provides (such as multi-dimensional arrays). These data
structures require that memory be allocated (reserved) for their use, so that instructions that
execute after they're allocated don't corrupt them.

Memory allocation is a high-level concept, not an EVM concept. Its implementation in Solidity relies
on the value stored in the free memory pointer stored at location ``0x40``. That value tracks the next
unallocated memory address available. This is different from the highest memory address ever accessed
by the contract's code. Memory access opcodes in inline assembly are not restricted by the value of
the free memory pointer and can freely refer to memory located beyond it.

Every time you access memory, the EVM knows the location that was accessed. Roughly speaking, the
maximum location you access determines the size of active memory. Increasing the size of
active memory increases your gas costs non-linearly. The specifics are beyond the scope
of this documentation. More information about gas costs can be found in the Etherum Yellow Paper
and in the EVM (go-ethereum) project and specifications.

The concepts of "active memory size" and "allocated memory" are distinct and separate. The former is
managed by the EVM. The latter is managed by Solidity's generated code and the free memory pointer
at location ``0x40``.

The active memory size is available via the inline assembly instruction ``msize()`` (see
:ref:`opcodes`). There is no dedicated opcode for accessing the free memory pointer. The address
``0x40`` is just an ordinary memory location that is managed by code automatically generated by
the compiler. In inline assembly memory can be allocated manually by increasing the value of the
free memory pointer.

To be clear, there is nothing special about accessing the free memory pointer. Accessing the free
memory pointer itself is a memory access. After accessing the free memory pointer ``msize()`` would
(by definition) return a value that is no smaller than the location of the free memory pointer
plus its size: ``0x40 + 0x20``.

The memory between locations ``0x00`` and ``0x3F`` (inclusive) is called "scratch space." It exists
solely by convention. Solidity's generated code observes the convention that this area is for
extremely brief temporary use only. Since there is no guarantee that code not under your direct
control will not change that memory, you should not rely on its value being preserved between statements
except within the current assembly block.

The zero slot at ``0x60`` was used as the initial value for dynamic memory arrays by earlier versions
of Solidity, and may still be used for that purpose. It must never
be written to. See `Layout of Arrays in Memory`.

The free memory pointer points to ``0x80`` initially. The Solidity compiler generates code that
always places new objects at the location pointed to by the free memory pointer. Memory is never
"freed" (this might change in the future). In other words, in the current version of Solidity, the
free memory pointer is never reduced (moved back) by Solidity.

.. warning::
    There are some operations in Solidity that need a temporary memory area
    larger than 64 bytes and therefore will not fit into the scratch space.
    Code for these operations therefore uses the unallocated area past
    the free memory pointer. Because such operations are known to be complete
    before the next instruction or operation managed by Solidity, the generated
    code does not update the free memory pointer. The memory used in such operations
    may or may not be zeroed out after the operation is complete. Solidity's
    access of that memory may affect ``msize()``. Thus, it is reasonable to expect that
    ``msize()`` might be larger than the value of the free memory pointer.

    While it may seem like a good idea to use ``msize()`` to arrive at a
    definitely zeroed out memory area (by using the memory just beyond its
    return value) using such a pointer non-temporarily without updating the
    free memory pointer can have unexpected results. Nothing prevents inline assembly
    from accessing any memory location whatsoever, but updating the free memory pointer
    at ``0x40`` at least ensures that Solidity itself won't unexpectedly use memory
    located below its value.

    In brief, the memory between ``0x00 - 0x3F`` and the memory after the location
    pointed to by the free memory pointer can be considered scratch memory, and can be freely
    used between Solidity instructions via inline assembly, as long as you do not rely on it not being
    overwritten afterwards.

Layout of Arrays in Memory
==========================

Elements in memory arrays in Solidity always occupy multiples of 32 bytes, i.e.
one slot (this is even true for ``bytes1[]``, but not for ``bytes`` and ``string``).
Multi-dimensional memory arrays are pointers to memory arrays. The length of a
dynamic array is stored at the first slot of the array and followed by the array
elements.

Dynamically sized memory arrays (e.g., ``uint[]``) store their length in
the first slot pointed to by the array variable, followed by its elements in the following
slots. Although memory arrays are not resizable, they may be allocated dynamically using
the ``new`` keyword. In some versions of Solidity, the initial value of the dynamically
sized memory array variable itself is set to ``0x60``, see
`Reserved Memory Areas`_. The slot at ``0x60``
maintains a zero value (by convention). Once allocated, dynamically sized memory arrays
cannot change their size.

.. note::
    Inline assembly has the potential to corrupt
    the value in that slot, or could incorrectly change the length encoding of an array - see
    :ref:`Memory Safety <assembly-memory-safety>`. This issue is mentioned here purely for completeness. Corruption of
    slot ``0x60`` should not occur in well behaved contracts.

.. note::
     In current versions of Solidity it does not cause an error to decrease the length encoded
     in the first slot of dynamically sized arrays.

.. warning::
    Statically-sized memory arrays do not have a length field, but it might be added in a future version
    to allow better convertibility between statically- and dynamically-sized arrays, so
    do not rely on this.


Differences to Layout in Storage
================================

As described above the layout in memory is different from the layout in
:ref:`storage<storage-inplace-encoding>`. Below there are some examples.

Example for Difference in Arrays
--------------------------------

The following array occupies 32 bytes (1 slot) in storage, but 128
bytes (4 items with 32 bytes each) in memory.

.. code-block:: solidity

    uint8[4] a;



Example for Difference in Struct Layout
---------------------------------------

The following struct occupies 96 bytes (3 slots of 32 bytes) in storage,
but 128 bytes (4 items with 32 bytes each) in memory.


.. code-block:: solidity

    struct S {
        uint a;
        uint b;
        uint8 c;
        uint8 d;
    }
